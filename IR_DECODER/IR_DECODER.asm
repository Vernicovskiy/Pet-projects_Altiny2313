/*
Программа реализующая принятие и декодирование команд с пультов дистанционного управления

Для приема сигнала с вывода инфрокрасного приемника используется 
таймер 1 работающий в режиме захвата.
Вывод ИК-приемника должен быть подклчен к выводу захвата ICP
В микроконтроллере ATtiny2313 вывод захвата - PD6 (11 вывод).
ВЫВОД ЗАХВАТА ОБЯЗАТЕЛЬНО ДОЛЖЕН БЫТЬ НАСТРОЕН НА ВХОД

Микроконтроллер 	ATtiny2313
Тактовая частота 	8 MHz
*/
.include "tn2313def.inc"


;ПОРТ УПРАВЛЕНИЯ
.equ	PORT_CMD			=PORTB
.equ	DDR_CMD				=DDRB
.equ	PIN_CMD				=PINB
;ВЫВОД УПРАВЛЕНИЯ
.equ	Command_1			=PB6	;Вывод для индикации выполнения первой команды
.equ	Command_2			=PB5	;Вывод для индикации выполнения второй команды
.equ	Command_3			=PB4	;Вывод для индикации выполнения третей команды


;###########################################
;#### ТАЙМФРЕЙМЫ ПУЛЬТА В МИКРОСЕКУНДАХ ####
;###########################################
;СТАРТОВЫЙ ИМПУЛЬС
.equ	Time_Start			=3000
.equ	Tolerance_Str		=200	;Величина погрешности стартового импульса
;ДЛИННЫЙ ИМПУЛЬС (ЛОГИЧЕСКАЯ 1)
.equ	Time_pulse_1		=1800
.equ	Tolerance_1			=100	;Величина погрешности длинного импульса
;КОРОТКИЙ ИМПУЛЬС (ЛОГИЧЕСКИЙ 0)
.equ	Time_pulse_0		=1200
.equ	Tolerance_0			=100	;Величина погрешности короткого импульса
;ВРЕМЯ ДО ДЕШИФРАЦИИ КОМАНДЫ
.equ	Time_to_decod		=3500



;ОПРЕДЕЛЕНИЕ РЕГИСТРОВ
.def	Save_SREG			=R2		;Регистр для сохранения регистра SREG
.def	byte_1				=R10	;Четыре байта для хранения принятого кода
.def	byte_2				=R11
.def	byte_3				=R12
.def	byte_4				=R13
.def	temp				=R16
.def	FLAGS				=R17	;Регистр флагов

;БИТЫ РЕГИСТРА FLAGS
.equ	Package_OK			=0		;Бит признака принятия посылки
.equ	Package_FAIL		=1		;Бит ошибки кодирования длительности импульса
.equ	IR_IS_ON			=2		;Бит присутствия IR-сигнала в течение 65536 мкс


;#### МАКРО ОПРЕДЕЛЕНИЯ ####
.macro	table						;Загрузка адреса констант
		ldi		ZH,high(@0*2)
		ldi		ZL,low (@0*2)
.endm
.macro	ldz							;Загрузка константы в 16-разрядный регистр
		ldi		ZH,high(@0)
		ldi		ZL,low (@0)
.endm
.macro	outi						;Запись константы в РВВ
		ldi		R16,@1
		out		@0,R16
.endm



;#### НАЧАЛО ПРОГРАММНОГО КОДА ####
.cseg
.org	0x00
		rjmp	INIT			;ИНИЦИАЛИЗАЦИЯ
.org	ICP1addr
		rjmp	TIM1_CAPT		;ЗАХВАТ ТАЙМЕРА 1
.org	OC1Aaddr
		rjmp	TIM1_COMP_A		;СОВПАДЕНИЕ В КАНАЛЕ А ТАЙМЕРА 1
.org	OVF1addr
		rjmp	TIM1_OVER		;ПЕРЕПОЛНЕНИЕ ТАЙМЕРА 1


;#### ИНИЦИАЛИЗАЦИЯ ####
.org	INT_VECTORS_SIZE
INIT:		outi	SPL,RAMEND
			outi	PORTD,0xFF			;Вывод порта PD6 на вход

			outi	DDR_CMD,0xFF		;Выводы порта B на выход
			outi	PORT_CMD,0x00		;На всех выводах логический ноль
			outi	TIMSK,(1<<OCIE1A|1<<ICIE1|1<<TOIE1)	;ПРЕРЫВАНИЕ ПО СОВПАДЕНИЮ В КАНАЛЕ А,
														;ПРЕРЫВАНИЕ ПО ПЕРЕПОЛНЕНИЮ, ПРЕРЫВАНИЕ ПО ЗАХВАТУ
			outi	OCR1AH,high(Time_to_decod)			;Загрузка в регистр совпадения константы
			outi	OCR1AL,low (Time_to_decod)

			rcall	Restart_IR			;Инициализация таймера, флагов, байтов данных, сброс флагов прерываний, разрешение прерываний

			
;###### ОСНОВНОЙ ЦИКЛ ######
MAIN:		rcall	Check_IR			;Вызов подпрограммы проверки получения посылки 
			rjmp	MAIN				
			
Check_IR:	sbrs	FLAGS,Package_OK	;Пропуск reti, если посылка принята
			reti						;Выход из подпрограммы с установкой флага глобального разрешения прерываний
			sbrs	FLAGS,Package_FAIL	;Пропуск вызова подпрограммы дешифровки принятой команды, если в процессе приема был принят некорректный импульс
			rcall	decoder				;ДЕШИФРАЦИЯ ПРИНЯТОЙ КОМАНДЫ
			sbrc	FLAGS,IR_IS_ON		;ОЖИДАНИЕ, ПОКА НЕ ПРЕКРАТЯТСЯ ПОСЫЛКИ С ПУЛЬТА (БИТ I ДОЛЖЕН БЫТЬ УСТАНОВЛЕН)
			rjmp	PC-1				;Ожидание установки бита отсутствия сигнала
			
Restart_IR:	outi	TCCR1B,0x00			;ЗАХВАТ - ПО CПАДУ, ОСТАНОВКА ТАЙМЕРА
			clr		FLAGS				;Сброс флагов
			clr		byte_1				;Очистка байтов принятых данных
			clr		byte_2
			clr		byte_3
			clr		byte_4
			outi	TIFR,0xFF			;Сброс всех флагов прерываний
			reti						;Разрешение прерываний
			
		
;ДЕКОДИРОВАНИЕ ПРИНЯТОЙ С ПУЛЬТА КОМАНДЫ
decoder:	cli									;Запрет прерываний на время дешифрации принятой команды
			table	P_OFF						;Загрузка кода кнопки OFF
			rcall	decod_cmd
			brts	OFF_COMMAND
				table	P_SOURCE				;Загрузка кода кнопки SOURCE
				rcall	decod_cmd
				brts	SOURCE_COMMAND
					table	P_VOL_UP			;Загрузка кода кнопки VOL_UP
					rcall	decod_cmd
					brts	VOL_UP_COMMAND
						table	P_VOL_DW		;Загрузка кода кнопки VOL_DW
						rcall	decod_cmd
						brts	VOL_DW_COMMAND
							table	P_DSPL		;Загрузка кода кнопки DSPL
							rcall	decod_cmd
							brts	DSPL_COMMAND
							reti				;Установка флага разрешения прерываний после дешифрации принятой команды

OFF_COMMAND:	sbi		PIN_CMD,Command_1
				reti						;Установка флага разрешения прерываний после дешифрации принятой команды
SOURCE_COMMAND:	sbi		PIN_CMD,Command_2
				reti						;Установка флага разрешения прерываний после дешифрации принятой команды
VOL_UP_COMMAND:	sbi		PIN_CMD,Command_3
				reti						;Установка флага разрешения прерываний после дешифрации принятой команды
VOL_DW_COMMAND:	sbi		PIN_CMD,Command_1
				reti						;Установка флага разрешения прерываний после дешифрации принятой команды
DSPL_COMMAND:	sbi		PIN_CMD,Command_2
				reti						;Установка флага разрешения прерываний после дешифрации принятой команды


;ПРОЦЕДУРА СРАВНЕНИЯ ПРИНЯТЫХ БАЙТ С БАЙТАМИ КОМАНД ПУЛЬТА
decod_cmd:	clt						;Сброс флага совпадения
			lpm		temp,Z+			;Загрузка байта команды из памяти
			cp		temp,byte_4		;Сравнение с принятым байтом
			brne	No_cmd			;Если байт не совпадает, то выход из подпрограммы со сброшенным флагом совпадения
			lpm		temp,Z+
			cp		temp,byte_3
			brne	No_cmd
			lpm		temp,Z+
			cp		temp,byte_2
			brne	No_cmd
			lpm		temp,Z+
			cp		temp,byte_1
			brne	No_cmd
			set						;Установка флага совпадения
No_cmd:		ret


;ПРЕРЫВАНИЕ ПО СРАВНЕНИЮ ТАЙМЕРА
TIM1_COMP_A:	sbr		FLAGS,(1<<Package_OK)		;Установка флага признака принятия посылки
				reti
				
;ПРЕРЫВАНИЕ ПО ПЕРЕПОЛНЕНИЮ ТАЙМЕРА
TIM1_OVER:		cbr		FLAGS,(1<<IR_IS_ON)			;Сброс флага присутствия IR-сигнала в течение 65536 мкс
				ret									;Запрет прерываний после установки 
				
;ПРЕРЫВАНИЕ ПО ЗАХВАТУ
TIM1_CAPT:		in		Save_SREG,SREG
				push	temp
				
				outi	TCNT1H,0x00					;Очистка счетных регистров таймера 1
				outi	TCNT1L,0x00
				in		XL,ICR1L					;Считывание значения длительности импульса из регистра захвата
				in		XH,ICR1H	
				
				sbrc	FLAGS,IR_IS_ON				;Если первое прерывание, то пропуск декодирования импульса
				rcall	Decoder_Pulse				;Вызов подпрограммы декодирования длительности принятого импульса
				
				outi	TCCR1B,(1<<CS11)			;Запуск таймера в работу (ДЕЛЕНИЕ НА 8, ЗАХВАТ - ПО CПАДУ)
				sbr		FLAGS,(1<<IR_IS_ON)			;Установка флага присутствия IR-сигнала в течение 65536 мкс
				pop		temp					
				out		SREG,Save_SREG
				reti

;##### ДЕШИФРОВКА ДЛИТЕЛЬНОСТИ ПРИНЯТОГО ИМПУЛЬСА #####
Decoder_Pulse:		rcall	Detect_1				;Сравнение с длительностью импульса логической 1
					brcc	Detect_Pulse_Is_1		;Сохранение дешифрованного импульса логической 1 в память
					rcall	Detect_0				;Сравнение с длительностью импульса логического 0
					brcc	Detect_Pulse_Is_0		;Сохранение дешифрованного импульса логического 0 в память
					rcall	Detect_Start			;Сравнение с длительностью СТАРТ-импульса
					brcc	PC+2					;Если стартовый импульс успешно дешифрован, то просто выходим
					sbr		FLAGS,(1<<Package_FAIL)	;Длительность импульса дешифровать неудалось. Установка флага ошибки Package_FAIL
					ret

Detect_Pulse_Is_1:	sec								;Сдвиг флага С = 1 в байты данных
Detect_Pulse_Is_0:	rol		byte_1					;Сдвиг флага С = 0 в байты данных
					rol		byte_2
					rol		byte_3
					rol		byte_4
					ret

					
;МАКРОС ДЕШИФРОВКИ ДЛИТЕЛЬНОСТИ ИМПУЛЬСА
.macro				Detect_Impulse
					ldz		@0 + @1			;Проверка на превышение верхней границы
					rcall	Calc_Pulse		;Сравнение длительности принятого импульса с эталонной величиной
					brcs	Pulse_OK		;Если С=1, то принятый импульс меньше верхней границы (это "правильный" импульс)
					sec						;С=0 => принятый импульс больше верхней границы (это "НЕправильный" импульс)
					ret						;Устанавливаем флаг ошибки C=1 и выходим
Pulse_OK:			ldz		@0 - @1			;Проверка на значение меньшее, чем нижняя граница
					rcall	Calc_Pulse		;Если С=0, то принятый импульс больше нижней границы (это "правильный" импульс)
					ret						;Если С=1, то принятый импульс меньше нижней границы (это "НЕправильный" импульс)
.endm

;СРАВНЕНИЕ ДЛИТЕЛЬНОСТИ ИМПУЛЬСА С ЭТАЛОННЫМИ ЗНАЧЕНИЯМИ
Detect_Start:		Detect_Impulse		Time_Start,   Tolerance_Str	;ПРОВЕРКА СТАРТОВОГО ИМПУЛЬСА
Detect_1:			Detect_Impulse		Time_pulse_1, Tolerance_1	;ПРОВЕРКА ДЛИННОГО ИМПУЛЬСА (1)
Detect_0:			Detect_Impulse		Time_pulse_0, Tolerance_0	;ПРОВЕРКА КОРОТКОГО ИМПУЛЬСА (0)

Calc_Pulse:			mov		temp,XL			;Сравнение длительности импульса с эталонной величиной
					sub		temp,ZL
					mov		temp,XH
					sbc		temp,ZH
					ret


;####################################################################
;						КОДЫ КОМАНД ПУЛЬТА
;Для каждого кода отводится 4 байта. Отсутствующие биты - нули 
;####################################################################
;				   Старший байт						   Младший байт

P_OFF:		.db		0b00000000, 0b00000000, 0b00101100, 0b00010000	;OFF
P_SOURCE:	.db		0b00000000, 0b00000000, 0b00011000, 0b10010000	;SOURCE
P_MODE:		.db		0b00000000, 0b00000000, 0b00111000, 0b10010000	;MODE
P_ATT:		.db		0b00000000, 0b00000000, 0b00001010, 0b00010000	;ATT
P_SEL:		.db		0b00000000, 0b00000000, 0b00100010, 0b00010000	;SEL
P_UP:		.db		0b00000000, 0b00000000, 0b00110011, 0b00010000	;UP
P_DW:		.db		0b00000000, 0b00000000, 0b00010011,	0b00010000	;DOWN
P_RIGHT:	.db		0b00000000, 0b00000000, 0b00001011,	0b00010000	;RIGHT
P_LEFT:		.db		0b00000000, 0b00000000, 0b00101011,	0b00010000	;LEFT
P_VOL_UP:	.db		0b00000000, 0b00000000, 0b00010010,	0b00010000	;VOL_UP
P_VOL_DW:	.db		0b00000000, 0b00000000, 0b00110010,	0b00010000	;VOL_DW
P_DSPL:		.db		0b00000000, 0b00000000, 0b00000101,	0b00010000	;DSPL
P_SCRL:		.db		0b00000000, 0b00000000, 0b00110001,	0b00010000	;SCRL
