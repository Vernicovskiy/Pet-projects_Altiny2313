/*	МАКРООПРЕДЕЛЕНИЯ АССЕМБЛЕРА & ПОДКЛЮЧЕНИЕ БИБЛИОТЕЧНЫХ ФАЙЛОВ & КОМАНДЫ УСЛОВНОГО АССЕМБЛИРОВАНИЯ


		### УСЛОВНОЕ АССЕМБЛИРОВАНИЕ ###
			
&& - Логическое умножение
|| - Логическое сложение

.if	<УСЛОВИЕ>						;Задание условия [больше(>), больше или равно(>=), меньше(<), меньше или равно(<=), равен(==), неравен(!=)]
	<ДЕЙСТВИЕ>						;Если условие выполняется, то печатай это действие
.endif								;Иначе, просто пропускай печать действия


.if	<УСЛОВИЕ 1>						;Задание условия [больше(>), больше или равно(>=), меньше(<), меньше или равно(<=), равен(==), неравен(!=)]
	<ДЕЙСТВИЕ 1>					;Если условие выполняется, то прописывай действие 1
	.message "Print message 1"		;и выводи сообщение (только английские буквы)
	
.elif	<УСЛОВИЕ 2>					;Если предыдущее действие не выполняется, то проверяй это
		<ДЕЙСТВИЕ 2>				;печатай действие 2
		.message "Print message 2"	;и выводи сообщение 2
									;ВЫХОД
.elif	<УСЛОВИЕ 3>					;Если предыдущее действие не выполняется, то проверяй это
		<ДЕЙСТВИЕ 3>				;печатай действие 3
		.message "Print message 3"	;и выводи сообщение 3
									;ВЫХОД
.elif	<УСЛОВИЕ 4>					;Если предыдущее действие не выполняется, то проверяй это
		.error "Print error"		;Остановка трансляции программы с ошибкой "Print error"
			
.else								;Если ни одно из действий после .if не выполнилось, то
	<ДЕЙСТВИЕ 5>					;печатай действие 5
.endif								;Конец условия .if


		### МАКРООПРЕДЕЛЕНИЯ АССЕМБЛЕРА ###

Макроопределения всегда должны быть определены прежде чем они будут использованы. 
Другими словами, определения макросов должны распологаться 
по тексту программы ВЫШЕ, чем строки программы в которых они используются

.macro		Начало макроса
.endm		Конец макроса
.endmacro	Конец макроса
@0			Первый параметр
@1			Второй параметр
@2			Третий параметр
...			
@9			Десятый (последний) параметр	
*/



		;###########################
		;### ОБЪЯВЛЕНИЕ МАКРОСОВ ###
		;###########################

.macro    ldx           ;Загрузка в регистр X слова
	ldi		XL,low (@0)
    ldi		XH,high(@0)
.endm
;ПРИМЕР:		ldx		0x25F9

.macro    clbr          ;Сброс разряда в РОН
    cbr		@0,(1<<@1)
.endm
;ПРИМЕР:	clbr	temp,1

.macro    stbr          ;Установка разряда в РОН
    sbr		@0,(1<<@1)
.endm
;ПРИМЕР:	stbr	temp,1

/*ИЛИ ТАК
.macro    clbr          ;Сброс разряда в РОН
    cbr		@0,exp2(@1)
.endm*/

.macro	outi			;Загрузка числа в РВВ
	ldi		R16,@1
	out		@0,R16
.endm
;ПРИМЕР:		outi	DDRB,0b11001100

/*
.macro	outi			;Загрузка числа в РВВ c сохранением в стеке регистра R16
	push	R16
	ldi		R16,@1
	out		@0,R16
	pop		R16
.endm

.macro	outv			;Загрузка числа в РВВ с выбором промежуточного РОН
	ldi		@2,@1
	out		@0,@2
.endm
;ПРИМЕР:		outv	DDRB,0b11001100,temp
*/

.macro	subi16			;Вычетание числа из 16-и разрядного регистра 
	subi	@0L,low (@1)
	sbci	@0H,high(@1)
.endm
;ПРИМЕР:		subi16	X,0x25F9

/*ИЛИ ТАК
.macro	subi16			;Вычетание числа из 16-и разрядного регистра 
	subi	@0L,byte1(@1)
	sbci	@0H,byte2(@1)
.endm*/

.macro    table         ;Загрузка в регистр Z адреса начала таблицы констант в памяти программ
	ldi		ZL,low (@0*2)
    ldi		ZH,high(@0*2)
.endm

;УСТАНОВКА РАЗРЯДА В ЯЧЕЙКЕ ПАМЯТИ ДАННЫХ ИЛИ РВВ
.macro setb
	.if @1>7 
		.message "Only values 0-7 allowed for Bit parameter" 
	.endif 
	.if @0>0x3F 			;Установка бита в ячейке памяти данных
		lds  @2, @0 
		sbr  @2, (1<<@1) 
		sts  @0, @2 
	.elif @0>0x1F 			;Установка бита в РВВ с адресом большим чем 0x1F
		in   @2, @0 
		sbr  @2, (1<<@1) 
		out  @0, @2 
	.else 					;Установка бита в РВВ с адресом меньшим чем 0x1F
		sbi  @0, @1 
	.endif 
.endm




.include "tn2313def.inc"		;К проетту добавлен файл описаний



.def	temp		=R16
.equ	VD			=1			;Вывод порта, для подключения светодиода

		;##################################
		;#### НАЧАЛО ПРОГРАММНОГО КОДА ####
		;##################################
.cseg
.org	0x00
		rjmp	start	;Переход на начало программного кода (!)
		
		.include	"DELAY.inc"			;Подключение к проекту файла DELAY.inc

;		.include	"C:\LIB\MACROS.inc"	;Подключение к проекту файла макросов с указанием полного пути

;		.include	"MACROS.inc"		;Подключение к проекту файла макросов без указания пути (файл лежит в папке проекта)


start:	outi	SPL,RAMEND				;Инициализация стека
		


.equ	Const1		=5
.equ	Const2		=20
.equ	bool		=1
		
		inc		temp

		.if		Const1 == 21
				nop
				ldi		R18,0x80		;Если условие выполняется, то прописывай эту комманду и выводи это сообщение
				nop
		.endif

		inc		temp


		.if		((Const1 < Const2 * 2)||(Const1 == Const2))&&bool
				ldi		R17,0x40		;Если условие выполняется, то прописывай эту комманду и выводи это сообщение
				.message "((Const1 < Const2 * 2)||(Const1 == Const2))&&bool  condition fulfilled"
		.endif



		.if	Const1 == 20								;Если условие выполняется,
			ldi		temp,1								;то выполняется команда ldi	temp,1
			.message "Print message 1"					;и печатается сообщение. После всех действий, ВЫХОД
				.elif	Const1 == 21					;Если предыдущее условие не выполнено, то проверка следующего
						ldi		temp,2
						.message "Print message 2"
				.elif	Const1 == 22					;Если предыдущее условие не выполнено, то проверка следующего	
						ldi		temp,3
						.message "Print message 3"
				.elif	Const1 == 23					;Если это условие выполняется, 
						.error "Print error"			;то остановка трансляции программы с ошибкой "Print error"
		.else											;Если ни одно из условий не выполнено, 
			ldi		temp,4								;то выполнение команды ldi	temp,4
		.endif
		
		

		.include	"CLEAR.inc"	;Очистка памяти данных и рон
		
		outi	DDRB,(1<<VD)	;В регистре DDRB в 1 установлен разряд VD
		outi	PORTB,0xFF		;В регистр PORTB загружено число 0xFF

		table	text			;В регистр Z загружен адрес начала таблицы констант

		setb	SREG,6,temp		;Установлен пользовательский флаг Т
		setb	0x60,1,temp		;Установлен бит 1 в ячейке 0х60

main:	rcall	_delay
		setb	PINB,VD,temp	;Переключение вывода VD порта В
		rjmp	main

text:
.db		0x01, 0x02, 0x03, 0xFF

