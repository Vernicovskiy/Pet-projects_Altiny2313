/*ГРУППА КОМАНД СРАВНЕНИЯ*/

.include "tn2313def.inc"

.def	temp	=R16
.def	temp2	=R17

;		#### КОМАНДА СРАВНЕНИЯ РЕГИСТРА И КОНСТАНТЫ ####
		ldi		temp,0x10
		cpi		temp,0x11;Флаг Z=0, следовательно, регистр НЕ РАВЕН константе
						 ;Флаг C=1, следовательно, регистр МЕНЬШЕ константы
		
		ldi		temp,0x11
		cpi		temp,0x11;Флаг Z=1, следовательно, регистр РАВЕН константе
						 ;Флаг C=0, следовательно, регистр БОЛЬШЕ или РАВЕН константе
						 
		ldi		temp,0x12
		cpi		temp,0x11;Флаг Z=0, следовательно, регистр НЕ РАВЕН константе
						 ;Флаг C=0, следовательно, регистр БОЛЬШЕ или РАВЕН константе

		clr		R12
	;	cpi		R12,0	 ;ОШИБКА! Команда cpi только для старших РОН (R16..R31)

;		#### КОМАНДА СРАВНЕНИЯ РЕГИСТРОВ ####
		ldi		temp,0x8C
		ldi		temp2,0x8C
		cp		temp,temp2	;Флаг Z=1, следовательно, регистры РАВНЫ
		
		inc		temp2
		cp		temp,temp2	;Флаг Z=0, следовательно, регистры НЕ РАВНЫ
							;Флаг C=1, следовательно, temp < temp2
							
		nop

.equ	content_Y			=0x542D	;Содержимое регистра Y
.equ	content_X			=0x542D ;Содержимое регистра X
.equ	const_comparation_1	=0x63FE
.equ	const_comparation_2	=0x2DFE
;#########################################################################################
;ТРЕБУЕТСЯ СРАВНИТЬ СОДЕРЖИМОЕ 16-РАЗРЯДНОГО РЕГИСТРА Y С КОНСТАНТОЙ const_comparation_1

;Загружаем в Y содержимое content_Y:
		ldi		YL,low(content_Y)
		ldi		YH,high(content_Y)
		
;Сначала сравниваем младшие байты регистра Y и константы const_comparation_1:
		cpi		YL,low(const_comparation_1)		
;После сравнения бит С=1, следовательно, младший байт const_comparation_1 БОЛЬШЕ YL
		
;Далее, во вспомогательный регистр temp, загружаем старший байт const_comparation_1:
		ldi		temp,high(const_comparation_1)

;И сравниваем старший байт регистра Y и сумму [старший байт(const_comparation_1) + С]:
		cpc		YH,temp		;Команда сравнения регистров с учетом флага переноса
		
;После сравнения бит С=1. Следовательно, const_comparation_1 БОЛЬШЕ содержимого Y
;#########################################################################################

		nop

;#########################################################################################
;ТРЕБУЕТСЯ СРАВНИТЬ СОДЕРЖИМОЕ 16-РАЗРЯДНОГО РЕГИСТРА Х С КОНСТАНТОЙ const_comparation_2

;Загружаем в X содержимое content_X:
		ldi		XL,low(content_X)
		ldi		XH,high(content_X)
		
;Сначала сравниваем младшие байты регистра X и константы const_comparation_2:
		cpi		XL,low(const_comparation_2)		
;После сравнения бит С=1, следовательно, младший байт const_comparation_2 БОЛЬШЕ XL
		
;Далее, во вспомогательный регистр temp, загружаем старший байт const_comparation_2:
		ldi		temp,high(const_comparation_2)

;И сравниваем старший байт регистра X и сумму [старший байт(const_comparation_2) + С]:
		cpc		XH,temp		;Команда сравнения регистров с учетом флага переноса
		
;После сравнения С=0, Z=0. Следовательно, const_comparation_2 МЕНЬШЕ содержимого X
;#########################################################################################

main:	rjmp	main
