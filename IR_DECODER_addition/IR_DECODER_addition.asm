/*
Программа реализующая принятие и декодирование команд с пультов дистанционного управления

Для приема сигнала с вывода инфрокрасного приемника используется 
таймер 1 работающий в режиме захвата.
Вывод ИК-приемника должен быть подклчен к выводу захвата ICP
В микроконтроллере ATtiny2313 вывод захвата - PD6 (11 вывод).
ВЫВОД ЗАХВАТА ОБЯЗАТЕЛЬНО ДОЛЖЕН БЫТЬ НАСТРОЕН НА ВХОД

Микроконтроллер 	ATtiny2313
Тактовая частота 	8 MHz
*/
.include "tn2313def.inc"


;ПОРТ УПРАВЛЕНИЯ
.equ	PORT_CMD			=PORTB
.equ	DDR_CMD				=DDRB
.equ	PIN_CMD				=PINB
;ВЫВОД УПРАВЛЕНИЯ
.equ	Command_1			=PB6	;Вывод для индикации выполнения первой команды
.equ	Command_2			=PB5	;Вывод для индикации выполнения второй команды
.equ	Command_3			=PB4	;Вывод для индикации выполнения третей команды


;###########################################
;#### ТАЙМФРЕЙМЫ ПУЛЬТА В МИКРОСЕКУНДАХ ####
;###########################################
;СТАРТОВЫЙ ИМПУЛЬС
.equ	Time_Start			=3000	;МИКРОСЕКУНД
.equ	Tolerance_Str		=300	;МИКРОСЕКУНД
;ДЛИННЫЙ ИМПУЛЬС (1)
.equ	Time_pulse_11		=3500	;МИКРОСЕКУНД
.equ	Tolerance_11		=200	;МИКРОСЕКУНД
.equ	Time_pulse_10		=2600	;МИКРОСЕКУНД
.equ	Tolerance_10		=300	;МИКРОСЕКУНД
;КОРОТКИЙ ИМПУЛЬС (0)
.equ	Time_pulse_01		=1800	;МИКРОСЕКУНД
.equ	Tolerance_01		=300	;МИКРОСЕКУНД
.equ	Time_pulse_00		=1800	;МИКРОСЕКУНД
.equ	Tolerance_00		=300	;МИКРОСЕКУНД
;ВРЕМЯ ДО ДЕШИФРАЦИИ КОМАНДЫ
.equ	Time_to_decod		=5000	;МИКРОСЕКУНД


;ОПРЕДЕЛЕНИЕ РЕГИСТРОВ
.def	Save_SREG			=R2		;Регистр для сохранения регистра SREG
.def	byte_1				=R10	;Четыре байта для хранения принятого кода
.def	byte_2				=R11
.def	byte_3				=R12
.def	byte_4				=R13
.def	temp				=R16
.def	FLAGS				=R17	;Регистр флагов

;БИТЫ РЕГИСТРА FLAGS
.equ	Package_OK			=0		;Бит признака принятия посылки
.equ	Package_FAIL		=1		;Бит ошибки кодирования длительности импульса
.equ	IR_IS_ON			=2		;Бит присутствия IR-сигнала в течение 65536 мкс


;#### МАКРО ОПРЕДЕЛЕНИЯ ####
.macro	table						;Загрузка адреса констант
		ldi		ZH,high(@0*2)
		ldi		ZL,low (@0*2)
.endm
.macro	ldz							;Загрузка константы в 16-разрядный регистр
		ldi		ZH,high(@0)
		ldi		ZL,low (@0)
.endm
.macro	outi						;Запись константы в РВВ
		ldi		R16,@1
		out		@0,R16
.endm



;#### НАЧАЛО ПРОГРАММНОГО КОДА ####
.cseg
.org	0x00
		rjmp	INIT			;ИНИЦИАЛИЗАЦИЯ
.org	ICP1addr
		rjmp	TIM1_CAPT		;ЗАХВАТ ТАЙМЕРА 1
.org	OC1Aaddr
		rjmp	TIM1_COMP_A		;СОВПАДЕНИЕ В КАНАЛЕ А ТАЙМЕРА 1
.org	OVF1addr
		rjmp	TIM1_OVER		;ПЕРЕПОЛНЕНИЕ ТАЙМЕРА 1


;#### ИНИЦИАЛИЗАЦИЯ ####
.org	INT_VECTORS_SIZE
INIT:		outi	SPL,RAMEND
			outi	PORTD,0xFF			;Вывод порта PD6 на вход

			outi	DDR_CMD,0xFF		;Выводы порта B на выход
			outi	PORT_CMD,0x00		;На всех выводах логический ноль
			outi	TIMSK,(1<<OCIE1A|1<<ICIE1|1<<TOIE1)	;ПРЕРЫВАНИЕ ПО СОВПАДЕНИЮ В КАНАЛЕ А,
														;ПРЕРЫВАНИЕ ПО ПЕРЕПОЛНЕНИЮ, ПРЕРЫВАНИЕ ПО ЗАХВАТУ
			outi	OCR1AH,high(Time_to_decod)			;Загрузка в регистр совпадения константы
			outi	OCR1AL,low (Time_to_decod)

			rcall	Restart_IR			;Инициализация таймера, флагов, байтов данных, сброс флагов прерываний, разрешение прерываний

			
;###### ОСНОВНОЙ ЦИКЛ ######
MAIN:		rcall	Check_IR			;Вызов подпрограммы проверки получения посылки 
			rjmp	MAIN				
			
Check_IR:	sbrs	FLAGS,Package_OK	;Пропуск reti, если посылка принята
			reti						;Выход из подпрограммы с установкой флага глобального разрешения прерываний
			sbrs	FLAGS,Package_FAIL	;Пропуск вызова подпрограммы дешифровки принятой команды, если в процессе приема был принят некорректный импульс
			rcall	decoder				;ДЕШИФРАЦИЯ ПРИНЯТОЙ КОМАНДЫ
			sbrc	FLAGS,IR_IS_ON		;ОЖИДАНИЕ, ПОКА НЕ ПРЕКРАТЯТЬСЯ ПОСЫЛКИ С ПУЛЬТА (БИТ I ДОЛЖЕН БЫТЬ УСТАНОВЛЕН)
			rjmp	PC-1				;Ожидание установки бита отсутствия сигнала
			
Restart_IR:	outi	TCCR1B,0x00			;ЗАХВАТ - ПО CПАДУ, ОСТАНОВКА ТАЙМЕРА
			clr		FLAGS				;Сброс флагов
			clr		byte_1				;Очистка байтов принятых данных
			clr		byte_2
			clr		byte_3
			clr		byte_4
			outi	TIFR,0xFF			;Сброс всех флагов прерываний
			reti						;Разрешение прерываний
			
		
;ДЕКОДИРОВАНИЕ ПРИНЯТОЙ С ПУЛЬТА КОМАНДЫ
decoder:	cli									;Запрет прерываний на время дешифрации принятой команды
			table	P_POWER_0					;Загрузка кода кнопки POWER (10 бит)
			rcall	decod_cmd
			brts	POWER_COMMAND
			table	P_POWER_1					;Загрузка кода кнопки POWER (9 бит)
			rcall	decod_cmd
			brts	POWER_COMMAND
				table	P_DISP_0				;Загрузка кода кнопки DISPLAY (10 бит)
				rcall	decod_cmd
				brts	DISP_COMMAND
				table	P_DISP_1				;Загрузка кода кнопки DISPLAY (11 бит)
				rcall	decod_cmd
				brts	DISP_COMMAND
					table	P_PROG_0			;Загрузка кода кнопки PROG (8 бит)
					rcall	decod_cmd
					brts	PROG_COMMAND
					table	P_PROG_1			;Загрузка кода кнопки PROG (9 бит)
					rcall	decod_cmd
					brts	PROG_COMMAND
						table	P_RPT_0			;Загрузка кода кнопки REPEAT (9 бит)
						rcall	decod_cmd
						brts	RPT_COMMAND
						table	P_RPT_1			;Загрузка кода кнопки REPEAT (11 бит)
						rcall	decod_cmd
						brts	RPT_COMMAND
							reti				;Установка флага разрешения прерываний после дешифрации принятой команды

POWER_COMMAND:	sbi		PIN_CMD,Command_1
				reti						;Установка флага разрешения прерываний после дешифрации принятой команды
DISP_COMMAND:	sbi		PIN_CMD,Command_2
				reti						;Установка флага разрешения прерываний после дешифрации принятой команды
PROG_COMMAND:	sbi		PIN_CMD,Command_3
				reti						;Установка флага разрешения прерываний после дешифрации принятой команды
RPT_COMMAND:	sbi		PIN_CMD,Command_1
				reti						;Установка флага разрешения прерываний после дешифрации принятой команды


;ПРОЦЕДУРА СРАВНЕНИЯ ПРИНЯТЫХ БАЙТ С БАЙТАМИ КОМАНД ПУЛЬТА
decod_cmd:	clt						;Сброс флага совпадения
			lpm		temp,Z+			;Загрузка байта команды из памяти
			cp		temp,byte_4		;Сравнение с принятым байтом
			brne	No_cmd			;Если байт не совпадает, то выход из подпрограммы со сброшенным флагом совпадения
			lpm		temp,Z+
			cp		temp,byte_3
			brne	No_cmd
			lpm		temp,Z+
			cp		temp,byte_2
			brne	No_cmd
			lpm		temp,Z+
			cp		temp,byte_1
			brne	No_cmd
			set						;Установка флага совпадения
No_cmd:		ret


;ПРЕРЫВАНИЕ ПО СРАВНЕНИЮ ТАЙМЕРА
TIM1_COMP_A:	sbr		FLAGS,(1<<Package_OK)		;Установка флага признака принятия посылки
				outi	TCCR1B,(1<<CS11|1<<CS10)	;ДЕЛЕНИЕ НА 64 (для увеличения времени ожидания отпускания кнопки)
				reti
				
;ПРЕРЫВАНИЕ ПО ПЕРЕПОЛНЕНИЮ ТАЙМЕРА
TIM1_OVER:		cbr		FLAGS,(1<<IR_IS_ON)			;Сброс флага присутствия IR-сигнала в течение 65536 мкс
				ret									;Запрет прерываний после установки 
				
;ПРЕРЫВАНИЕ ПО ЗАХВАТУ
TIM1_CAPT:		in		Save_SREG,SREG
				push	temp
				
				outi	TCNT1H,0x00					;Очистка счетных регистров таймера 1
				outi	TCNT1L,0x00
				in		XL,ICR1L					;Считывание значения длительности импульса из регистра захвата
				in		XH,ICR1H	
				
				sbrc	FLAGS,IR_IS_ON				;Если первое прерывание, то пропуск декодирования импульса
				rcall	Decoder_Pulse				;Вызов подпрограммы декодирования длительности принятого импульса
				
				outi	TCCR1B,(1<<CS11)			;Запуск таймера в работу (ДЕЛЕНИЕ НА 8, ЗАХВАТ - ПО CПАДУ)
				sbr		FLAGS,(1<<IR_IS_ON)			;Установка флага присутствия IR-сигнала в течение 65536 мкс
				pop		temp					
				out		SREG,Save_SREG
				reti

;##### ДЕШИФРОВКА ДЛИТЕЛЬНОСТИ ПРИНЯТОГО ИМПУЛЬСА #####
Decoder_Pulse:		rcall	Detect_11				;Сравнение с длительностью импульса логической 1
					brcc	Detect_Pulse_Is_1		;Сохранение дешифрованного импульса логической 1 в память
					rcall	Detect_10				;Сравнение с длительностью импульса логической 1
					brcc	Detect_Pulse_Is_1		;Сохранение дешифрованного импульса логической 1 в память
					rcall	Detect_01				;Сравнение с длительностью импульса логического 0
					brcc	Detect_Pulse_Is_0		;Сохранение дешифрованного импульса логического 0 в память
					rcall	Detect_00				;Сравнение с длительностью импульса логического 0
					brcc	Detect_Pulse_Is_0		;Сохранение дешифрованного импульса логического 0 в память
					rcall	Detect_Start			;Сравнение с длительностью СТАРТ-импульса
					brcc	PC+2					;Если стартовый импульс успешно дешифрован, то просто выходим
					sbr		FLAGS,(1<<Package_FAIL)	;Длительность импульса дешифровать неудалось. Установка флага ошибки Package_FAIL
					ret

Detect_Pulse_Is_1:	sec								;Сдвиг флага С = 1 в байты данных
Detect_Pulse_Is_0:	rol		byte_1					;Сдвиг флага С = 0 в байты данных
					rol		byte_2
					rol		byte_3
					rol		byte_4
					ret

					
;МАКРОС ДЕШИФРОВКИ ДЛИТЕЛЬНОСТИ ИМПУЛЬСА
.macro				Detect_Impulse
					ldz		@0 + @1			;Проверка на превышение верхней границы
					rcall	Calc_Pulse		;Сравнение длительности принятого импульса с эталонной величиной
					brcs	Pulse_OK		;Если С=1, то принятый импульс меньше верхней границы (это "правильный" импульс)
					sec						;С=0 => принятый импульс больше верхней границы (это "НЕправильный" импульс)
					ret						;Устанавливаем флаг ошибки C=1 и выходим
Pulse_OK:			ldz		@0 - @1			;Проверка на значение меньшее, чем нижняя граница
					rcall	Calc_Pulse		;Если С=0, то принятый импульс больше нижней границы (это "правильный" импульс)
					ret						;Если С=1, то принятый импульс меньше нижней границы (это "НЕправильный" импульс)
.endm

;СРАВНЕНИЕ ДЛИТЕЛЬНОСТИ ИМПУЛЬСА С ЭТАЛОННЫМИ ЗНАЧЕНИЯМИ
Detect_Start:		Detect_Impulse		Time_Start,    Tolerance_Str;ПРОВЕРКА СТАРТОВОГО ИМПУЛЬСА
Detect_11:			Detect_Impulse		Time_pulse_11, Tolerance_11	;ПРОВЕРКА ДЛИННОГО ИМПУЛЬСА (1)
Detect_10:			Detect_Impulse		Time_pulse_10, Tolerance_10	;ПРОВЕРКА КОРОТКОГО ИМПУЛЬСА (0)
Detect_01:			Detect_Impulse		Time_pulse_01, Tolerance_01	;ПРОВЕРКА ДЛИННОГО ИМПУЛЬСА (1)
Detect_00:			Detect_Impulse		Time_pulse_00, Tolerance_00	;ПРОВЕРКА КОРОТКОГО ИМПУЛЬСА (0)

Calc_Pulse:			mov		temp,XL			;Сравнение длительности импульса с эталонной величиной
					sub		temp,ZL
					mov		temp,XH
					sbc		temp,ZH
					ret


;####################################################################
;						КОДЫ КОМАНД ПУЛЬТА
;Для каждого кода отводится 4 байта. Отсутствующие биты - нули 
;####################################################################
;				   Старший байт						   Младший байт

P_POWER_0:	.db		0b00000000, 0b00000000, 0b00000000, 0b01100101	;POWER (10 бит)
P_POWER_1:	.db		0b00000000, 0b00000000, 0b00000000, 0b11100101	;POWER (9 бит)

P_DISP_0:	.db		0b00000000, 0b00000000, 0b00000000,	0b11001000	;DISPLAY (11 бит)
P_DISP_1:	.db		0b00000000, 0b00000000, 0b00000001,	0b11001000	;DISPLAY (10 бит)

P_PROG_0:	.db		0b00000000, 0b00000000, 0b00000000, 0b01111111	;PROG (8 бит)
P_PROG_1:	.db		0b00000000, 0b00000000, 0b00000000, 0b00111111	;PROG (9 бит)

P_RPT_0:	.db		0b00000000, 0b00000000, 0b00000000, 0b11101001	;REPEAT (9 бит)
P_RPT_1:	.db		0b00000000, 0b00000000, 0b00000000, 0b01101001	;REPEAT (11 бит)


